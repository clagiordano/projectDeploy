#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  projectDeploy
#
#  Version 2.0
#
#  Copyright 2014 - 2015 Claudio Giordano <claudio.giordano@autistici.org>
#
#  Homepage https://github.com/clagiordano/projectDeploy.git
#  Homepage https://clagiordano@bitbucket.org/clagiordano/projectDeploy.git
#
#  License GPLv3 https://www.gnu.org/licenses/gpl.html

import sys
import os
import tempfile
import ConfigParser
import argparse
from distutils.spawn import find_executable
import subprocess
import ConfigParser
import re

""" Local import """
import modules.outputUtils as out
import modules.confirm as confirm
from modules.projectDeployConfiguration import ProjectDeployConfiguration

"""
Main class
"""
class ProjectDeploy(object):
    def setDeployConfig(self):
        #~ print self.Configuration

        # Read custom config file if present (override default)
        # TODO: import config from bash config to python vars
        #~ if [ -e "${CONFIG_CONF_PATH}" ];
        if os.path.isfile(self.Configuration.configPath) \
            and os.access(self.Configuration.configPath, os.R_OK):
            out.success("Found custom config file.")
            self.Configuration.readConfigFile(self.Configuration.configPath)
        #~ then
            #~ success "Found custom config file.";

            #~ if eval ". ${CONFIG_CONF_PATH}"
            #~ then
                #~ success "Import custom config file.";
            #~ else
                #~ fatalError "Import custom config file.";
            #~ fi
        #~ fi

        # Parse command line args (override default and custom config)
        #~ parseArgs $*;
        #echo "[$(date +'%Y-%m-%d %H:%M:%S')]: $*" >> "${CONFIG_LOG_PATH}";

        if self.argsParsed.root:
            out.success("Override default projects root to '" + self.argsParsed.root + "'")
            self.Configuration.defaultProjectsRoot = self.argsParsed.root

    def setArgParser(self):
        parser = argparse.ArgumentParser()
        #~ parser.add_argument("-d", "--dialog", action='store_true', help="Enable dialog output")
        parser.add_argument("-v", "--verbose", action='store_true', help="Enable verbose output")
        parser.add_argument("-t", "--text", action='store_true', help="Enable text output")
        parser.add_argument("-b", "--debug", action='store_true', help="Enable debug output")
        parser.add_argument("-m", "--multitarget", action='store_true', help="Enable multi target mode")
        parser.add_argument("-r", "--root", help="Change projects root")
        self.argsParsed = parser.parse_args()

    """
    Check presence of required bynary file
    """
    def binaryCheck(self, commandToCheck, isRequired):
        out.debug("[binaryCheck]: commandToCheck %s, isRequired %s" \
            % (commandToCheck, isRequired), self.Configuration.debugMode)
        executable = find_executable(commandToCheck)
        if executable and isRequired:
            out.success("Found required " + commandToCheck + " in path " + executable)
        if (executable and not isRequired):
            out.success("Found optional " + commandToCheck + " in path " + executable)
        elif (not executable and not isRequired):
            out.warning("Cannot find optional" + commandToCheck)
        elif (not executable and isRequired):
            out.fatalError("Cannot find requested " + commandToCheck)

    def createProjectsList(self):
        self.projectsList = {}
        if (os.path.isdir(self.Configuration.defaultProjectsRoot)):
            dirContent = os.listdir(self.Configuration.defaultProjectsRoot)
            dirContent.sort()
            index = 1
            for element in dirContent:
                if (os.path.isdir(self.Configuration.defaultProjectsRoot + "/" + element)):
                    self.projectsList[index] = element.strip()
                    index += 1
            out.debug(self.projectsList, self.Configuration.debugMode)
        else:
            out.fatalError("Invalid project root '" + self.Configuration.defaultProjectsRoot + "'")

    def createDestinationsList(self):
        self.destinationsList = {}
        filePath = self.targetFilePath
        if self.Configuration.multitargetMode:
            filePath = self.multiTargetFilePath

        targetsList = open(filePath, "r").readlines()

        index = 1
        for element in targetsList:
            if (not element.startswith('#') and (element != '\n')):
                self.destinationsList[index] = element.strip()
                index += 1

        if (len(self.destinationsList) < 1):
            out.fatalError("No entries in target file '" + filePath + "'")

    def selectFromList(self, selectionList, listTitle = ""):
        if (listTitle == ""):
            listTitle = "%s [ \033[1;34m%s\033[0m ]: " % \
                (self.Configuration.dialogTitle, self.Configuration.defaultProjectsRoot)
        self.printList(selectionList, listTitle)

        choosed = False
        while (choosed == False):
            selection = raw_input(self.Configuration.deploySelectFromListMsg)
            out.debug("Selection input: " + selection, self.Configuration.debugMode)
            if selection == "0":
                out.warning(self.Configuration.deployAbortMsg)
                sys.exit(0)
            elif re.match("^(\d+)$", selection):
                selection = int(selection)
                if (selection > 0 and selection <= len(selectionList)):
                    choosed = True
                    out.debug("         SELECTION: " + str(selection), self.Configuration.debugMode)
                    out.debug("          SELECTED: '" + selectionList[selection] +  "'", self.Configuration.debugMode)
                    #self.confirmProjectSelection(selectionList[selection])
                else:
                    out.error("Invalid choice '\033[1;31m" + str(selection)
                    + "\033[0m', please insert only the number corresponding to an element of the list.\n");
            else:
                out.error("Invalid choice '\033[1;31m" + str(selection)
                + "\033[0m', please insert only the number corresponding to an element of the list.\n");

        return selection

    def selectTargets(self):
        subprocess.call("clear")
        if (not os.path.isdir(self.projectConfigDir)):
            out.warning("Missing configuration directory, created empty at '\033[1;32m" + self.projectConfigDir + "\033[0m'")
            os.mkdir(self.projectConfigDir)

        self.targetFilePath = self.projectConfigDir + "/" + self.Configuration.syncTargetsFile
        self.multiTargetFilePath = self.projectConfigDir + "/" + self.Configuration.syncMultiTargetsFile

        self.targetsAvailable = os.path.isfile(self.targetFilePath)
        self.multiTargetsAvailable = os.path.isfile(self.multiTargetFilePath)

        if ((self.targetsAvailable == False) \
            and (self.multiTargetsAvailable == False)):
            out.fatalError("No targets file detected!")

        if (self.multiTargetsAvailable):
            answer = confirm.getConfirm("Enable multi target mode for this project? [y/N]:")
            if (answer == True):
                self.Configuration.multitargetMode = True
                out.success("Multi targets mode ENABLED")

        self.ignoreFile = os.path.isfile(self.Configuration.syncIgnoresFile)

    #~ Print numbered formatted list
    def printList(self, listData, listHeader = "Select an element from list:"):
        #~ List header with empty line before
        print "\n%s\n" % (listHeader)

        for elementId in listData:
            sys.stdout.write( \
                "[\033[1;34m%4d\033[0m]: %-25s" \
                % (elementId, listData[elementId][0:24]) \
            )

            if (elementId % 3) == 0:
                sys.stdout.write('\n')

        sys.stdout.write('\n')

        if (elementId % 3) != 0:
            sys.stdout.write('\n')

    def init(self):
        subprocess.call("clear")
        # Create base config object as default config
        self.Configuration = ProjectDeployConfiguration()
        self.setArgParser()
        # Set deploy config
        self.setDeployConfig()
        # Global counters
        self.syncSuccess = 0
        self.syncFailed = 0

    def binaryChecks(self):
        subprocess.call("clear")
        # Check binary files
        self.binaryCheck("git", False)
        self.binaryCheck("rsync", True)

    def selectProject(self):
        subprocess.call("clear")
        # Project list creation and selection
        self.createProjectsList()
        selection = self.selectFromList(self.projectsList)
        print ""
        out.success("Selected element '\033[1;32m" + self.projectsList[selection] + "\033[0m'")
        self.projectConfigDir = self.Configuration.basePath + "/" + self.projectsList[selection]
        self.projectSourceDir = self.Configuration.defaultProjectsRoot + self.projectsList[selection]

    def selectTarget(self):
        subprocess.call("clear")
        # Targets list creation and selection
        self.selectTargets()

        subprocess.call("clear")
        self.createDestinationsList()
        selection = self.selectFromList(self.destinationsList, "Choose a destination from targets list: ")
        print ""
        out.success("Selected element '\033[1;32m" + self.destinationsList[selection] + "\033[0m'")
        self.selectedTarget = self.destinationsList[selection]

    def printRecap(self):
        subprocess.call("clear")
        # TODO Print deploy recap
        print "\n-- Deploy Recap --"
        print "Projects root: %s" % self.Configuration.defaultProjectsRoot
        print "Project config directory: %s" % self.projectConfigDir
        print "Multi target mode: %s" % self.Configuration.multitargetMode
        print "Selected source directory: %s" % self.projectSourceDir
        print "Selected target directory: %s" % self.selectedTarget

    """
    Run sync command and simulation
    """
    def startSync(self, target, dryrun=True):
        self.syncCommand = "rsync " + self.Configuration.rsyncOptions + " "

        if dryrun == True:  # Dry run?
            self.syncCommand += "--dry-run "

        if self.ignoreFile == True:
            self.syncCommand += self.Configuration.syncIgnoresFile

        self.syncCommand += self.projectSourceDir + "/" + self.selectedTarget

        if  self.Configuration.verboseMode == True:
            self.syncCommand += "&> ${TEMP_FILE}"

        """
        if eval "${SYNC_COMMAND}"
        then
            let "SYNC_SUCCESS += 1";
            OUTPUT_STATUS=`grep '^sent' "${TEMP_FILE}"`;
            success "Sync status: ${OUTPUT_STATUS}";
        else
            let "SYNC_FAIL += 1";
            #OUTPUT_STATUS=`cat "${TEMP_FILE}"`;
            #error "Sync status: ${OUTPUT_STATUS}";
            while read LINE
            do
                error "Sync status: ${LINE}";
            done < "${TEMP_FILE}"
        fi"""

    """
    def deploy(self, target, dryrun=True):
        if dryrun == True:  # Dry run?
            #RSYNC_OPTIONS=${RSYNC_OPTIONS}" --dry-run";
            startSync \"${TARGET}\" \"dryrun\";
        else:
            # Check and execute pre sync script
            if [[ -e "${CONFIG_DIR}/${SYNC_PRE_FILE}" ]];
            then
                chmod +x "${CONFIG_DIR}/${SYNC_PRE_FILE}";

                # FIXME echo "mi sposto nella cartella: ${PROJECT_ROOT}/${SELECTED_PROJECT}/";
                if eval "cd ${PROJECT_ROOT}/${SELECTED_PROJECT}/";
                then
                    if eval "${CONFIG_DIR}/${SYNC_PRE_FILE}";
                    then
                        success "Executing pre-sync hook.";
                    else
                        fatalError "${SYNC_PRE_FILE} execution error!";
                    fi
                else
                    fatalError "Failed to change dir to ${PROJECT_ROOT}/${SELECTED_PROJECT}/";
                fi;
                eval "cd - > /dev/null"; # > /dev/null;
            fi;

            startSync "${TARGET}";

            # Check and execute post sync script
            if [[ -e "${CONFIG_DIR}/${SYNC_POST_FILE}" ]];
            then
                chmod +x "${CONFIG_DIR}/${SYNC_POST_FILE}";

                # FIXME echo "mi sposto nella cartella: ${PROJECT_ROOT}/${SELECTED_PROJECT}/";
                if eval "cd ${PROJECT_ROOT}/${SELECTED_PROJECT}/";
                    then
                    if eval  "${CONFIG_DIR}/${SYNC_POST_FILE}"
                    then
                        success "Executing post-sync hook.";
                    else
                        fatalError "${SYNC_POST_FILE} execution error!";
                    fi
                else
                    fatalError "Failed to change dir to ${PROJECT_ROOT}/${SELECTED_PROJECT}/";
                fi;
                eval "cd - > /dev/null"; # ;
            fi;
        fi;
    """

    def __init__(self):
        self.init()
        self.binaryChecks()
        self.selectProject()
        self.selectTarget()
        self.printRecap()

        if (confirm.getConfirm("Start simulation deploy? [y/N]:")):
            pass

if __name__ == "__main__":
    try:
        projectdeploy = ProjectDeploy()
    except KeyboardInterrupt as e:
        print "\n"
        out.warning("CTRL-C detected, deploy aborted!")
