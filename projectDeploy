#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  projectDeploy
#
#  Version 2.0
#
#  Copyright 2014 - 2015 Claudio Giordano <claudio.giordano@autistici.org>
#
#  Homepage https://github.com/clagiordano/projectDeploy.git
#  Homepage https://clagiordano@bitbucket.org/clagiordano/projectDeploy.git
#
#  License GPLv3 https://www.gnu.org/licenses/gpl.html

import sys
import os
import tempfile
import ConfigParser
import argparse
from distutils.spawn import find_executable

""" 
Configuration class for ProjectDeploy
"""
class ProjectDeployConfiguration(object):
    def __init__(self):
        # Tempfile for rsync output and dialog configuration
        self.tempFile = tempfile.mkstemp()[1];
        self.dialogTempFile = tempfile.mkstemp()[1];

        # Script name configuration
        #~ scriptName = __file__
        self.scriptName = "projectDeploy"

        # Path configuration
        self.basePath = os.environ['HOME'] + "/." + self.scriptName
        self.logPath = self.basePath + "/." + self.scriptName + ".log"
        self.configPath = self.basePath + "/." + self.scriptName + ".conf"
        self.defaultProjectsRoot = "/tmp"

        # Projects file configurations with default value
        self.syncPreFile          = "pre-sync"
        self.syncPostFile         = "post-sync"
        self.syncIgnoresFile      = "ignores"
        self.syncTargetsFile      = "targets"
        self.syncMultiTargetsFile = "multitargets"
        self.syncExtraOptions     = "rsync-extra"
        
        # Switch configuration
        self.dialogMode               = False
        self.verboseMode              = False
        self.debugMode                = False
        self.multitargetMode          = False
        self.multitargetModeAvailable = False

        # Messages configurations
        self.dialogTitle = "Choose a project to deploy from"
        self.deployMsg = "Choose a project's number to deploy or 0 to abort: "
        self.deployAbortMsg = "Deploy aborted."
        self.deploySelectFromListMsg = "Select an element from list or 0 to abort: "

        # NOTE: Option info none only suppported from rsync protocol v.31
        # Classic output verbose with percentage progress for single file
        self.rsyncOptions = "-arvzhi --progress --delete"
        # Solo output avanzamento globale, %, velocità e stats finali al termine
        self.rsyncOptions = "-arzh --info=none,progress2,stats --delete"
        # Solo output avanzamento globale, % e velocità
        self.rsyncOptions = "-arzhvi --info=progress2 --delete"

        # Dialog config
        # Auto-size with height and width = 0. Maximize with height and width = -1.
        self.dialogType             = "menu"
        self.dialogMenuHeight       = 0
        self.dialogMenuWidth        = 0
        self.dialogMenuMenuHeight   = 0

"""
Main class 
"""
class ProjectDeploy(object):
    def setDeployConfig(self):
        # Create base config object as default config
        self.Configuration = ProjectDeployConfiguration();
        #~ print self.Configuration
        
        # Read custom config file if present (override default)
        # TODO: import config from bash config to python vars
        #~ if [ -e "${CONFIG_CONF_PATH}" ];
        #~ then
            #~ success "Found custom config file.";

            #~ if eval ". ${CONFIG_CONF_PATH}"
            #~ then
                #~ success "Import custom config file.";
            #~ else
                #~ fatalError "Import custom config file.";
            #~ fi
        #~ fi
        
        # Parse command line args (override default and custom config)
        #~ parseArgs $*;
    
    def fatalError(self, message):
        print "[\033[1;31mFATAL ERROR\033[0m]: " + message;
        sys.exit(1)
        
    def error(self, message):
        print "[\033[1;31mERROR\033[0m      ]: " + message;
        
    def success(self, message):
        print "[\033[1;32mSUCCESS\033[0m    ]: " + message;
        
    def warning(self, message):
        print "[\033[1;33mWARNING\033[0m    ]: " + message;
        
    def debug(self, message):
        if (self.Configuration.debugMode == True):
            print "\033[1;30m[DEBUG      ]: %s\033[0m" % message

    """
    Write a message to logfile
    """
    def log2file(self, message):
        #echo "[$(date +'%Y-%m-%d %H:%M:%S')]: $*" >> "${CONFIG_LOG_PATH}";
        pass
    
    def setArgParser(self):
        parser = argparse.ArgumentParser()
        #~ parser.add_argument("-d", "--dialog", action='store_true', help="Enable dialog output")
        parser.add_argument("-v", "--verbose", action='store_true', help="Enable verbose output")
        parser.add_argument("-t", "--text", action='store_true', help="Enable text output")
        parser.add_argument("-b", "--debug", action='store_true', help="Enable debug output")
        parser.add_argument("-m", "--multitarget", action='store_true', help="Enable multi target mode")
        parser.add_argument("-r", "--root", help="Change projects root")
        
        args = parser.parse_args()
        print "[Debug]: %s" % args
        
    """
    Check presence of required bynary file
    """
    def binaryCheck(self, commandToCheck, isRequired):
        self.debug("[binaryCheck]: commandToCheck %s, isRequired %s" % (commandToCheck, isRequired))
        executable = find_executable(commandToCheck)
        #~ print "[Debug]: %s" % (executable)
        if (executable and isRequired):
            self.success("Found required " + commandToCheck + " in path " + executable)
        if (executable and not isRequired):
            self.success("Found optional " + commandToCheck + " in path " + executable)
        elif (not executable and not isRequired):
            self.warning("Cannot find optional" + commandToCheck)
        elif (not executable and isRequired):
            self.fatalError("Cannot find requested " + commandToCheck)

    def printList(self, listData):
        pass

    def __init__(self):
        # TODO Clear screen
        
        self.setArgParser()
        
        # Set deploy config
        self.setDeployConfig()
        
        # Check binary files
        self.binaryCheck("git", False)
        self.binaryCheck("rsync", True)
        
        # Global counters
        self.syncSuccess = 0
        self.syncFailed = 0
        

if __name__ == "__main__":
    projectdeploy = ProjectDeploy()
