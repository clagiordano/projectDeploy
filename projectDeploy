#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  projectDeploy
#
#  Version 2.0
#
#  Copyright 2014 - 2015 Claudio Giordano <claudio.giordano@autistici.org>
#
#  Homepage https://github.com/clagiordano/projectDeploy.git
#  Homepage https://clagiordano@bitbucket.org/clagiordano/projectDeploy.git
#
#  License GPLv3 https://www.gnu.org/licenses/gpl.html

import sys
import os
import tempfile
import ConfigParser
import argparse
from distutils.spawn import find_executable
import subprocess
import ConfigParser

""" Local import """
import outputUtils as out

""" 
Configuration class for ProjectDeploy
"""
class ProjectDeployConfiguration(object):
    def __init__(self):
        # Tempfile for rsync output and dialog configuration
        self.tempFile = tempfile.mkstemp()[1];
        self.dialogTempFile = tempfile.mkstemp()[1];

        # Script name configuration
        #~ scriptName = __file__
        self.scriptName = "projectDeploy"

        # Path configuration
        self.basePath = os.environ['HOME'] + "/." + self.scriptName
        self.logPath = self.basePath + "/" + self.scriptName + ".log"
        self.configPath = self.basePath + "/" + self.scriptName + ".conf"
        self.defaultProjectsRoot = "/tmp"

        # Projects file configurations with default value
        self.syncPreFile          = "pre-sync"
        self.syncPostFile         = "post-sync"
        self.syncIgnoresFile      = "ignores"
        self.syncTargetsFile      = "targets"
        self.syncMultiTargetsFile = "multitargets"
        self.syncExtraOptions     = "rsync-extra"
        
        # Switch configuration
        self.dialogMode               = False
        self.verboseMode              = False
        self.debugMode                = False
        self.multitargetMode          = False
        self.multitargetModeAvailable = False

        # Messages configurations
        self.dialogTitle = "Choose a project to deploy from"
        self.deployMsg = "Choose a project's number to deploy or 0 to abort: "
        self.deployAbortMsg = "Deploy aborted."
        self.deploySelectFromListMsg = "Select an element from list or 0 to abort: "

        # NOTE: Option info none only suppported from rsync protocol v.31
        # Classic output verbose with percentage progress for single file
        self.rsyncOptions = "-arvzhi --progress --delete"
        # Solo output avanzamento globale, %, velocità e stats finali al termine
        self.rsyncOptions = "-arzh --info=none,progress2,stats --delete"
        # Solo output avanzamento globale, % e velocità
        self.rsyncOptions = "-arzhvi --info=progress2 --delete"

        # Dialog config
        # Auto-size with height and width = 0. Maximize with height and width = -1.
        self.dialogType             = "menu"
        self.dialogMenuHeight       = 0
        self.dialogMenuWidth        = 0
        self.dialogMenuMenuHeight   = 0

    
    def readConfigFile(self, filePath):
        
        """ Test config file"""
        try:
            #~ New config file
            cp = ConfigParser.ConfigParser()
            conf = cp.read(filePath);
            print "[Debug]: %s" % (conf)
            out.success("Found new config file")
        except:
            #~ Old config file
            fileContent = open(filePath, "r").read()
            out.warning("Found OLD config file")
            print "[Debug]: %s" % (fileContent)
            self.migrateOldConfigfile(fileContent)
            
        #~ try:
            #~ print("[Debug]: PRE test bash vars: %s" % (os.getenv['PROJECT_ROOT']))
            #~ print("[Debug]: PRE test bash vars: %s" % (os.environ['PROJECT_ROOT']))
        #~ except:
            #~ print "[Debug]: var not found"
            
        #~ fileContent = open(filePath, "r").read()
        #~ print "[Debug]: %s" % (fileContent)

    #~ def testConfigFile(self, filePath)

    def migrateOldConfigfile(self, optionsList):
        pass
        
"""
Main class 
"""
class ProjectDeploy(object):
    def setDeployConfig(self):
        # Create base config object as default config
        self.Configuration = ProjectDeployConfiguration();
        #~ print self.Configuration
                
        # Read custom config file if present (override default)
        # TODO: import config from bash config to python vars
        #~ if [ -e "${CONFIG_CONF_PATH}" ];
        if os.path.isfile(self.Configuration.configPath) \
            and os.access(self.Configuration.configPath, os.R_OK):
                out.success("Found custom config file.")
                self.Configuration.readConfigFile(self.Configuration.configPath)
        #~ then
            #~ success "Found custom config file.";

            #~ if eval ". ${CONFIG_CONF_PATH}"
            #~ then
                #~ success "Import custom config file.";
            #~ else
                #~ fatalError "Import custom config file.";
            #~ fi
        #~ fi
        
        # Parse command line args (override default and custom config)
        #~ parseArgs $*;
        #echo "[$(date +'%Y-%m-%d %H:%M:%S')]: $*" >> "${CONFIG_LOG_PATH}";
        pass
    
    def setArgParser(self):
        parser = argparse.ArgumentParser()
        #~ parser.add_argument("-d", "--dialog", action='store_true', help="Enable dialog output")
        parser.add_argument("-v", "--verbose", action='store_true', help="Enable verbose output")
        parser.add_argument("-t", "--text", action='store_true', help="Enable text output")
        parser.add_argument("-b", "--debug", action='store_true', help="Enable debug output")
        parser.add_argument("-m", "--multitarget", action='store_true', help="Enable multi target mode")
        parser.add_argument("-r", "--root", help="Change projects root")
        
        args = parser.parse_args()
        #~ out.debug(args, self.Configuration.debugMode)
        
    """
    Check presence of required bynary file
    """
    def binaryCheck(self, commandToCheck, isRequired):
        out.debug("[binaryCheck]: commandToCheck %s, isRequired %s" \
            % (commandToCheck, isRequired), self.Configuration.debugMode)
        executable = find_executable(commandToCheck)
        #~ print "[Debug]: %s" % (executable)
        if (executable and isRequired):
            out.success("Found required " + commandToCheck + " in path " + executable)
        if (executable and not isRequired):
            out.success("Found optional " + commandToCheck + " in path " + executable)
        elif (not executable and not isRequired):
            out.warning("Cannot find optional" + commandToCheck)
        elif (not executable and isRequired):
            out.fatalError("Cannot find requested " + commandToCheck)

    def printList(self, listData):
        pass

    def __init__(self):
        subprocess.call("clear")
        
        self.setArgParser()
        
        # Set deploy config
        self.setDeployConfig()
        
        # Check binary files
        self.binaryCheck("git", False)
        self.binaryCheck("rsync", True)
        
        # Global counters
        self.syncSuccess = 0
        self.syncFailed = 0
        

if __name__ == "__main__":
    projectdeploy = ProjectDeploy()
